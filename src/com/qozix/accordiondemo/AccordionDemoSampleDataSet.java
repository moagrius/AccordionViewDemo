package com.qozix.accordiondemo;

import java.util.ArrayList;

public class AccordionDemoSampleDataSet {

	private ArrayList<AccordionDemoQuestionAnswerSet> faqs = new ArrayList<AccordionDemoQuestionAnswerSet>();
	{
		faqs.add( new AccordionDemoQuestionAnswerSet( "Do all the Activities and Services of an application run in a single process?", "All Activities and Services in an application run in a single process by default. If needed, you can declare an android:process attribute in your manifest file, to explicitly place a component (Activity/Service) in another process." ) );
		faqs.add( new AccordionDemoQuestionAnswerSet( "Do all Activities run in the main thread of an application process?", "By default, all of the application code in a single process runs in the main UI thread. This is the same thread that also handles UI events. The only exception is the code that handles IPC calls coming in from other processes. The system maintains a separate pool of transaction threads in each process to dispatch all incoming IPC calls. The developer should create separate threads for any long-running code, to avoid blocking the main UI thread." ) );
		faqs.add( new AccordionDemoQuestionAnswerSet( "How do I pass data between Activities/Services within a single application?", "It depends on the type of data that you want to share: Primitive Data Types\n To share primitive data between Activities/Services in an application, use Intent.putExtras(). For passing primitive data that needs to persist use the Preferences storage mechanism.\n Non-Persistent Objects\n For sharing complex non-persistent user-defined objects for short duration, the following approaches are recommended:\n Singleton class\n You can take advantage of the fact that your application components run in the same process through the use of a singleton. This is a class that is designed to have only one instance. It has a static method with a name such as getInstance() that returns the instance; the first time this method is called, it creates the global instance. Because all callers get the same instance, they can use this as a point of interaction. For example activity A may retrieve the instance and call setValue(3); later activity B may retrieve the instance and call getValue() to retrieve the last set value.\n A public static field/method\n An alternate way to make data accessible across Activities/Services is to use public static fields and/or methods. You can access these static fields from any other class in your application. To share an object, the activity which creates your object sets a static field to point to this object and any other activity that wants to use this object just accesses this static field.\n A HashMap of WeakReferences to Objects\n You can also use a HashMap of WeakReferences to Objects with Long keys. When an activity wants to pass an object to another activity, it simply puts the object in the map and sends the key (which is a unique Long based on a counter or time stamp) to the recipient activity via intent extras. The recipient activity retrieves the object using this key.\n Persistent Objects\n Even while an application appears to continue running, the system may choose to kill its process and restart it later. If you have data that you need to persist from one activity invocation to the next, you need to represent that data as state that gets saved by an activity when it is informed that it might go away.\n For sharing complex persistent user-defined objects, the following approaches are recommended:\n Application Preferences\n Files contentProviders SQLite DB If the shared data needs to be retained across points where the application process can be killed, then place that data in persistent storage like Application Preferences, SQLite DB, Files or ContentProviders. Please refer to the Data Storage for further details on how to use these components." ) );
		faqs.add( new AccordionDemoQuestionAnswerSet( "How can I check if an Activity is already running before starting it?", "The general mechanism to start a new activity if its not running— or to bring the activity stack to the front if is already running in the background— is the to use the NEW_TASK_LAUNCH flag in the startActivity() call." ) );
		faqs.add( new AccordionDemoQuestionAnswerSet( "If an Activity starts a remote service, is there any way for the Service to pass a message back to the Activity?", "See the Service documentation's for examples of how clients can interact with a service. You can take advantage of the fact that your components run in the same process to greatly simplify service interaction from the generic remote case, as shown by the \"Local Service Sample\". In some cases techniques like singletons may also make sense." ) );
		faqs.add( new AccordionDemoQuestionAnswerSet( "How to avoid getting the Application not responding dialog?", "Please read the Designing for Responsiveness document." ) );
		faqs.add( new AccordionDemoQuestionAnswerSet( "How does an application know if a package is added or removed?", "Whenever a package is added, an intent with PACKAGE_ADDED action is broadcast by the system. Similarly when a package is removed, an intent with PACKAGE_REMOVED action is broadcast. To receive these intents, you should write something like this:        <receiver android:name =\"com.android.samples.app.PackageReceiver\">\n <intent-filter> <action android:name=\"android.intent.action.PACKAGE_ADDED\"/> <action android:name=\"android.intent.action.PACKAGE_REMOVED\"/>               <data android:scheme=\"package\" />\n </intent-filter> </receiver> \n Here PackageReceiver is a BroadcastReceiver class.Its onReceive() method is invoked, every time an application package is installed or removed.Whenever a package is added, an intent with PACKAGE_ADDED action is broadcast by the system. Similarly when a package is removed, an intent with PACKAGE_REMOVED action is broadcast. To receive these intents, you should write something like this:        <receiver android:name =\"com.android.samples.app.PackageReceiver\">\n <intent-filter> <action android:name=\"android.intent.action.PACKAGE_ADDED\"/> <action android:name=\"android.intent.action.PACKAGE_REMOVED\"/>               <data android:scheme=\"package\" />\n </intent-filter> </receiver> \n Here PackageReceiver is a BroadcastReceiver class.Its onReceive() method is invoked, every time an application package is installed or removed." ) );

	}
	public ArrayList<AccordionDemoQuestionAnswerSet> getFaqs() {
		return faqs;
	}
}
